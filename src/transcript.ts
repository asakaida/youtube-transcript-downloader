import type { CaptionTrack, TranscriptLine } from "./types.ts";

const USER_AGENT =
	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36";

/**
 * Gets the Innertube API key from environment variable.
 * This is YouTube's public API key used by the web client.
 * Set YOUTUBE_INNERTUBE_API_KEY environment variable to override.
 */
function getInnertubeApiKey(): string {
	const apiKey = process.env.YOUTUBE_INNERTUBE_API_KEY;
	if (!apiKey) {
		throw new Error(
			"YOUTUBE_INNERTUBE_API_KEY environment variable is required. " +
				"This is YouTube's public Innertube API key used by the web client.",
		);
	}
	return apiKey;
}

/** Regular expressions for extracting video ID from various YouTube URL formats */
const VIDEO_ID_PATTERNS = [
	/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
	/^([a-zA-Z0-9_-]{11})$/,
] as const;

/** Regular expression for parsing transcript XML */
const TRANSCRIPT_TEXT_PATTERN =
	/<text\s+start="([^"]+)"\s+dur="([^"]+)"[^>]*>([^<]*)<\/text>/g;

/** HTML entity mappings for decoding */
const HTML_ENTITIES: Readonly<Record<string, string>> = {
	"&amp;": "&",
	"&lt;": "<",
	"&gt;": ">",
	"&quot;": '"',
	"&#39;": "'",
	"&apos;": "'",
	"&#x27;": "'",
	"&#x2F;": "/",
	"&nbsp;": " ",
};

/**
 * Extracts video ID from a YouTube URL or raw video ID string.
 *
 * @param url - YouTube URL or video ID
 * @returns The extracted video ID, or null if not found
 *
 * @example
 * ```ts
 * extractVideoId("https://www.youtube.com/watch?v=dQw4w9WgXcQ"); // "dQw4w9WgXcQ"
 * extractVideoId("https://youtu.be/dQw4w9WgXcQ"); // "dQw4w9WgXcQ"
 * extractVideoId("dQw4w9WgXcQ"); // "dQw4w9WgXcQ"
 * ```
 */
export function extractVideoId(url: string): string | null {
	for (const pattern of VIDEO_ID_PATTERNS) {
		const match = url.match(pattern);
		if (match?.[1]) {
			return match[1];
		}
	}
	return null;
}

/**
 * Fetches player information from YouTube's Innertube API.
 *
 * @param videoId - The YouTube video ID
 * @returns Player response data containing video metadata and captions
 * @throws Error if the request fails
 */
async function fetchPlayerInfo(
	videoId: string,
): Promise<Record<string, unknown>> {
	const url = `https://www.youtube.com/youtubei/v1/player?key=${getInnertubeApiKey()}`;

	const response = await fetch(url, {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
			"User-Agent": USER_AGENT,
			Origin: "https://www.youtube.com",
			Referer: "https://www.youtube.com/",
		},
		body: JSON.stringify({
			context: {
				client: {
					hl: "en",
					gl: "US",
					clientName: "WEB",
					clientVersion: "2.20231219.04.00",
				},
			},
			videoId,
		}),
	});

	if (!response.ok) {
		throw new Error(`Failed to fetch video info: ${response.status}`);
	}

	return response.json() as Promise<Record<string, unknown>>;
}

/**
 * Extracts available caption tracks from player response data.
 *
 * @param playerResponse - The player response object from YouTube API
 * @returns Array of available caption tracks
 */
export function extractCaptionTracks(
	playerResponse: Record<string, unknown>,
): CaptionTrack[] {
	const captions = playerResponse.captions as
		| Record<string, unknown>
		| undefined;
	if (!captions) {
		return [];
	}

	const playerCaptionsTracklistRenderer =
		captions.playerCaptionsTracklistRenderer as
			| Record<string, unknown>
			| undefined;
	if (!playerCaptionsTracklistRenderer) {
		return [];
	}

	const captionTracks = playerCaptionsTracklistRenderer.captionTracks as
		| Array<Record<string, unknown>>
		| undefined;
	if (!captionTracks) {
		return [];
	}

	return captionTracks.map((track) => {
		const name = track.name as Record<string, string> | undefined;
		const kind = track.kind as string | undefined;

		return {
			baseUrl: track.baseUrl as string,
			languageCode: track.languageCode as string,
			name: name?.simpleText ?? (track.languageCode as string),
			isAutoGenerated: kind === "asr",
		};
	});
}

/**
 * Fetches and parses transcript XML from the given URL.
 *
 * @param baseUrl - The caption track URL
 * @returns Array of parsed transcript lines
 * @throws Error if the request fails
 */
async function fetchTranscript(baseUrl: string): Promise<TranscriptLine[]> {
	const response = await fetch(baseUrl, {
		headers: {
			"User-Agent": USER_AGENT,
		},
	});

	if (!response.ok) {
		throw new Error(`Failed to fetch transcript: ${response.status}`);
	}

	const xml = await response.text();
	return parseTranscriptXml(xml);
}

/**
 * Parses YouTube transcript XML into structured data.
 *
 * @param xml - Raw XML string from YouTube's transcript API
 * @returns Array of parsed transcript lines
 */
function parseTranscriptXml(xml: string): TranscriptLine[] {
	const lines: TranscriptLine[] = [];

	for (const match of xml.matchAll(TRANSCRIPT_TEXT_PATTERN)) {
		const start = Number.parseFloat(match[1] ?? "0");
		const duration = Number.parseFloat(match[2] ?? "0");
		const text = decodeHtmlEntities(match[3] ?? "");

		lines.push({ text, start, duration });
	}

	return lines;
}

/**
 * Decodes HTML entities in a string.
 *
 * @param text - Text containing HTML entities
 * @returns Decoded text
 */
function decodeHtmlEntities(text: string): string {
	let result = text;

	for (const [entity, char] of Object.entries(HTML_ENTITIES)) {
		result = result.replaceAll(entity, char);
	}

	// Decode numeric character references (decimal)
	result = result.replace(/&#(\d+);/g, (_, code) =>
		String.fromCharCode(Number.parseInt(code, 10)),
	);

	// Decode numeric character references (hexadecimal)
	result = result.replace(/&#x([0-9a-fA-F]+);/g, (_, code) =>
		String.fromCharCode(Number.parseInt(code, 16)),
	);

	return result;
}

/**
 * Selects the best matching caption track based on language preference.
 *
 * @param tracks - Available caption tracks
 * @param preferredLang - Preferred language code (optional)
 * @returns The selected caption track, or null if none available
 * @throws Error if preferred language is not found
 */
function selectTrack(
	tracks: CaptionTrack[],
	preferredLang?: string,
): CaptionTrack | null {
	if (tracks.length === 0) {
		return null;
	}

	if (preferredLang) {
		// Exact match
		const exact = tracks.find((t) => t.languageCode === preferredLang);
		if (exact) return exact;

		// Prefix match (e.g., "en" matches "en-US")
		const partial = tracks.find((t) =>
			t.languageCode.startsWith(`${preferredLang}-`),
		);
		if (partial) return partial;

		throw new Error(
			`Language "${preferredLang}" not found. Use --list-langs to see available languages.`,
		);
	}

	// Prefer manually created captions over auto-generated
	const manual = tracks.find((t) => !t.isAutoGenerated);
	if (manual) return manual;

	return tracks[0] ?? null;
}

/**
 * Fetches the transcript for a YouTube video.
 *
 * @param videoId - The YouTube video ID
 * @param lang - Preferred language code (optional)
 * @returns Array of transcript lines
 * @throws Error if no captions are available or fetch fails
 *
 * @example
 * ```ts
 * const transcript = await getTranscript("dQw4w9WgXcQ", "en");
 * for (const line of transcript) {
 *   console.log(`[${line.start}] ${line.text}`);
 * }
 * ```
 */
export async function getTranscript(
	videoId: string,
	lang?: string,
): Promise<TranscriptLine[]> {
	const playerInfo = await fetchPlayerInfo(videoId);
	const tracks = extractCaptionTracks(playerInfo);

	if (tracks.length === 0) {
		throw new Error("No captions available for this video");
	}

	const track = selectTrack(tracks, lang);
	if (!track) {
		throw new Error("No caption track available");
	}

	return fetchTranscript(track.baseUrl);
}

/**
 * Lists all available caption tracks for a YouTube video.
 *
 * @param videoId - The YouTube video ID
 * @returns Array of available caption tracks
 *
 * @example
 * ```ts
 * const tracks = await listAvailableTracks("dQw4w9WgXcQ");
 * for (const track of tracks) {
 *   console.log(`${track.languageCode}: ${track.name}`);
 * }
 * ```
 */
export async function listAvailableTracks(
	videoId: string,
): Promise<CaptionTrack[]> {
	const playerInfo = await fetchPlayerInfo(videoId);
	return extractCaptionTracks(playerInfo);
}
